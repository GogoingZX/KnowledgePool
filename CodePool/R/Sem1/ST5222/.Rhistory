knitr::opts_chunk$set(echo = TRUE)
library(gtools)
k <- 3
Mixture <- function(lambda, n){
# Weights
set.seed(1)
Pi <- as.numeric(rep(1/k,k))
# simulate data from model
z <- numeric(n)   # missing data
x <- numeric(n)
# sample an z according to Pi
for(i in 1:n){
#z[i] represents that data i belongs to z[i]=j component
z[i] <- sample(c(1:k),1,replace = TRUE, prob = Pi)
x[i] <- rpois(1, lambda[z[i]])
}
return(list(x, lambda, k, n, Pi))
}
Return_value <- Mixture(c(10,50,100), 100)
x <- Return_value[[1]]
#plot data
hist(x, freq = F, nclass = 100, main="Simulated Data")
Gibbs <- function(Return_value, N){
x <- Return_value[[1]]
k <- Return_value[[3]]
n <- Return_value[[4]]
# initiate lambda
alpha <- 50; beta <- 0.5; set.seed(1)
lambda <- as.numeric(rgamma(k, alpha, beta))
lambda_0 <- lambda
# initiate Pi(weights)
set.seed(2)
Pi <- as.numeric(rdirichlet(1, c(rep(1,k))))
Pi_0 <- Pi
# initiate z (missing data)
updata_z <- function(seed){
prob_zij <- matrix(rep(0,n*k),n,k)
z <- numeric(n)
for(i in c(1:n)){
for(j in c(1:k)){
#Pi[j]*exp(-lambda[j])*(lambda[j])^(x[i])
prob_zij[i,j] <- Pi[j]*dpois(x[i],lambda[j])
}
for(j in c(1:k)){
prob_zij[i,j] <- prob_zij[i,j]/sum(prob_zij[i,])
}
z[i] <- sample(c(1:k),1,replace=F,prob = prob_zij[i,])
}
return(z)
}
z <- updata_z(1)
# the number of data in each component
sumI_and_sumxI <- function(z){
# the number of samples belong to class j
sumI <- numeric(k)
# sum all samples from class j
sumxI <- numeric(k)
for(j in 1:k){
sumI[j] <- length(which(z==j))
sumxI[j] <- sum(x[which(z==j)])
}
return(list(sumI,sumxI))
}
Result1 <- sumI_and_sumxI(z)
sumI <- Result1[[1]]
sumxI <- Result1[[2]]
# record simulation
lambdas <- matrix(rep(0,N*k),N,k)
Pis <- matrix(rep(0,N*k),N,k)
# main loop
for(loop in 1:N){
# update lambda
for(j in 1:k){
lambda[j] <- rgamma(1, alpha+sumxI[j], beta+sumI[j])
}
# update z
z <- updata_z(1)
Result1 <- sumI_and_sumxI(z)
sumI <- Result1[[1]]
sumxI <- Result1[[2]]
# update weight Pi
Pi <- as.numeric(rdirichlet(1, c(rep(1,k))+sumI))
# record updated parameters
lambdas[loop, ] <- lambda
Pis[loop, ] <- Pi
# break condition
sigma <- 0
# break loop or not
if(loop != 1){
J <- matrix(rep(0,2*k),2,k)
for(j in 1:k){
J[1,j] <- abs(lambdas[loop,j]-lambdas[(loop-1),j])<=sigma
J[2,j] <- abs(Pis[loop,j]-Pis[(loop-1),j])<=sigma
}
len <- length(which(J == FALSE))
if(len==0){break}
}
}
Converged_Pi <- Pis[loop,]
Converged_lambda <- lambdas[loop,]
Pis <- Pis[c(1:loop),]
lambdas <- lambdas[c(1:loop),]
return(list(Converged_Pi, Converged_lambda, Pis, lambdas))
}
# steps of iteration
N <- 10000
Result <- Gibbs(Return_value, N)
Converge_Pi <- Result[[1]]
Converge_lambda <- Result[[2]]
Pis <- Result[[3]]
lambdas <- Result[[4]]
#plot samples
plot(lambdas[,1],type="l",ylim=c(5,110),ylab="lambda")
lines(lambdas[,2],col=2)
lines(lambdas[,3],col=3)
par(mfrow=c(k,1))
for(i in 1:k)
{
plot(lambdas[,i],type="l")
}
par(mfrow=c(k,1))
for(i in 1:k)
{
plot(Pis[,i],type="l")
}
