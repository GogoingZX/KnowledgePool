---
title: "ST5226-Spatial Data"
author: "Zhu Xu"
date: "September 2018"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
###读取数据文件
```{r}
salary <- read.table("C:/Users/MSI/Desktop/R/files/salary.csv", sep = ",", header = TRUE, na.strings = "NA")
#1如果想要打开一个纯文本文件，可以使用read.table函数,其中第一个参数应该为代取文件名称（文件在工作目录中）或者代取文件的路径\n
#2参数sep告诉read.table需要使用什么分隔符，如果未设置sep，则read.table函数会默认空格为分隔符\n
#3参数header告诉函数是否将第一行作为变量名称而不是值如果是变量名称，则header=TRUE \n
#4参数代表使用什么表示缺失信息
salary <- read.table("C:/Users/MSI/Desktop/R/files/salary.csv", header = F, skip = 5, nrow = 1)
#使用skip告诉R在读取数据时忽略开头的一些行，nrow告诉R在读多少个数据行之后不再读取。
salary
```

一个面向对象系统的核心是其实现的类 (class) 和方法(method).\
class:类定义了对象共同拥有的某些属性及其与其他类的关系. \
如果一个对象属于某个类, 则称该对象是这个类的实例(instance).\
method:方法是一种与特定类的对象关联的函数.

##e.g.1：
```{r}
options(scipen = 10000,digits = 3) #10000以内的数不使用科学记数法，保留到三位小数
class(cars) #cars的类型
names(cars)
head(cars)
```
##e.g.2:
```{r}
head(cars)
cars[c(2,5,6),] #提取数据框"cars"中的第2,5,6行元素
cars
cars[,2] # 提取"cars"中第2列"dist"的所有元素
cars[,c("dist")]
cars[,1] # 提取"cars"中第1列"speed"的所有元素
cars[,"speed"]
cars[c(2,5,6),1] #提取"cars"中的第2,5,6行中的第1列"speed"元素
cars[c(2,5,6),"speed"]
cars$speed[c(2,5,6)] #从数据框"cars"中的"speed"列提取第2,5,6行元素
cars[c(2,5,6),2]#提取"cars"中的第2,5,6行的第2列"dist"元素
cars[c(2,5,6),"dist"]
cars$dist[c(2,5,6)]
```
##e.g.3:
```{r}
set.seed(1) 
#set.seed()括号中的数只是一个编号，作为标记使用，取值随意，当以后需要取得与上次相同随机数时，set.seed()括号中填回该值即可.如果不设定种子，生成的随机数无法重现.
ls1 <- list(A=rnorm(3),B=rnorm(5))
ls1
ls1[1]
ls1[[1]]
ls1["A"]
ls1[["A"]]
ls1$A
```
##e.g.4:
```{r}
ls1
saveRDS(ls1,file="ls1.rds")
ls2 <- readRDS("ls1.rds")
ls2
```
##e.g.5:
```{r}
hawkers <- readRDS("C:/Users/MSI/Desktop/Notes/ST5226-Spatial Statistics/Tut/onemap_hawker_ctr_raw.rds")
#注意读取文件时是使用符号"/"
length(hawkers)
str(hawkers[[1]],max.level = 1)
hawkers[[1]][[1]]
str(hawkers[[1]][[2]],max.level = 1)
```
##e.g.6:
```{r}
hawkers[[1]][1]
hawkers[[1]][2]
hw <- hawkers[[1]][-1]
# hawkers[[1]][-1] 删除[[1]]中的第1个元素
length(hw)
str(hw[5])
str(hw[[5]])
str(hw[[5]],max.level = 1)
street_name <- sapply(hw, function(x) x$ADDRESSSTREETNAME)
street_name
length(street_name)
street_name[1:5]
cars[1:3,]
# [-n]的用法
cars[1:3,][-1]
cars[1:3,][-2]
```
##e.g.7:
S3 Class:\
S3 实现了一种基于泛型函数的面向对象方式.\
泛型函数是一种特殊的函数, 其根据传入对象的类型决定调用哪个具体的方法.\
面向对象在 R 中的主要用途是 print, summary 和 plot 的方法. 这些方法允许我们仅仅使用一个泛型函数名, 比如summary(),就能根据一个对象不同的类型来显示它.
```{r}
cars
mod1 <- lm(dist ~ speed,data=cars)
class(mod1)
summary(cars)
summary(mod1)
```
##e.g.8:
我们可以使用 setClass() 函数来定义新的 S4 类型. \
Slots和S4对象类型相关.一个插槽可以被看作是一个部分，元素，或者对象的某个特性.\
比如你有一个对象是车，那么你就有slots：“价格”，“门的数量”，“发动机类型”，“里程数”.\
当已知属性名的时候, 可以使用 slot() 来查看.\
1.在定义S3类的时候，没有显式的定义过程，而定义S4类的时候需要调用函数setClass；\
2.在初始化S3对象的时候，只是建立了一个list，然后设置其class属性，而初始化S4对象时需要使用函数new；\
3.提取变量的符号不同，S3为$，而S4为@；\
4.在应用泛型函数时，S3需要定义f.classname，而S4需要使用setMethod函数；\
5.在声明泛型函数时，S3使用UseMethod()， 而S4使用setGeneric().
```{r}
library(sp)
getClass("Spatial") #包含2个slots, "bbox";"proj4string"
```
##e.g.9:(Spatial)
bbox()  提取对象的边界，结果第一行是从西到东的坐标范围；第二行是从南到北的坐标范围；\
proj4string()  提取投影字符串。此外还可以对proj4string进行赋值，如proj4string(sp.object) <- CRS(as.character(NA))\
coordinates()  提取坐标点矩阵。我们可以对矩阵取子集，得出符合要求的坐标点，如coordinates(sp.object)[c(1,3,5), ]
```{r}
m <- matrix(c(0,0,1,1), ncol=2,dimnames=list(NULL,c("min","max")))#定义一个坐标矩阵，即bbox
m
crs <- CRS(projargs = as.character(NA))#CRS=coordinate reference system(坐标参考系统)
crs
S <- Spatial(bbox = m, proj4string = crs)#projection(投影),CRS的类别class属于字符串，必须符合PROJ.4的字符串格式
#bbox=bounding box(边界),a matrix of numerical coordinates with column names
#(数字坐标的矩阵，表明这个空间数据覆盖的范围) 
#CRS的类别class属于字符类，必须符合proj.4的字符串格式
S
summary(S)#Spatial objects包含两个成分(slots):bbx,CRS
x.mytrix <- matrix(1:6, nrow = 2, ncol = 3,dimnames = list(c("row1","row2"),c("col1","col2","col3")))
#dimnames
rownames(x.mytrix)
colnames(x.mytrix)
```
##e.g.10:(Spatial Points)
The SpatialPoints class is the first subclass of Spatial.\
It allows us to represent points in space using pairs of numbers.\
```{r}
CRAN_df <- read.table("C:/Users/MSI/Desktop/Notes/ST5226-Spatial Statistics/CRAN051001a.txt", header = T)
#header = T/F 代表读取的数据第一行是否为标题行
CRAN_df
CRAN_mat <- cbind(CRAN_df$long, CRAN_df$lat)#longitude(经度),latitude(维度),"cbind": Take a sequence of vector, matrix or data-frame arguments and combine by columns or rows, respectively. 
CRAN_mat#
row.names(CRAN_mat) <- 1:nrow(CRAN_mat)#
row.names(CRAN_mat)#注意行标区别
llCRS <- CRS("+proj=longlat+ellps=WGS84")
#llCRS 会显示出 CRS arguments: +proj=longlat+ellps=WGS84
#在一幅地图里，如果没有声明CRS，那么x轴和y轴一单位是完全等同的，默认的屏幕长宽(aspect ratio)比也是根据图片的实际情况决定的.
CRAN_sp <- SpatialPoints(CRAN_mat,proj4string = llCRS)
#data_sp <- SpatialPoints(data_mat, proj4string = CRS)
CRAN_sp
summary(CRAN_sp)#包含3 slots: bbx,CRS,coords
#可以看到bbox(边界)，结果第一行是从西到东的坐标范围；第二行是从南到北的坐标范围.
#对象是否被投影whether the object is projected（需要注意，如果在proj4string这个slot里说明了投影方法，比如“+proj4 = longlat“，那么这里会显示FALSE）
#有多少个空间点（即坐标矩阵有多少行）
#相对于Spatial类，SpatialPoints更多了一个slot，即坐标coords
#coords的类别是矩阵matrix
coordinates(CRAN_sp)
#将所有坐标提取为数字矩阵
proj4string(CRAN_sp)
#可获取或者设置此对象的投影
```
Here are some of the functions that can be called on SpatialPoints objects.\
1.coordinates can be used to extract all the coordinates as a numeric matrix.
2.proj4string can be used to get or set the projection for this object.
##e.g.11:(Spatial Points Data Frame)
```{r}
CRAN_spdf1 <- SpatialPointsDataFrame(CRAN_mat, CRAN_df, proj4string=llCRS,match.ID = TRUE)
#构造SpatialPointsDataFrame对象有不同的方法，常见的包括基于坐标点矩阵和已有数据框之间的直接合并.
#如果坐标点矩阵有行名(row names)，match.id这一函数选项为TRUE，那么矩阵的行名将和数据框对应行名将自动进行比较，如果匹配上，则连接两者，并在适当情况下reorder数据框的顺序（keypoint！调整的是数据框的顺序），生成一个SpatialPointsDataFrame对象；如果没能匹配上，则不会生成任何SpatialPointsDataFrame对象。
CRAN_spdf1
#用中括号[]直接引用，这个时候会生成一个新的SpatialPointsDataFrame对象（注意是新的，和之前提到的SpatialPoints取子集一样）.
CRAN_spdf1[1,]#行操作，[]提取第一行信息
CRAN_spdf1[2,]#行操作，[]提取第二行信息
str(CRAN_spdf1, max.level = 2)
str(CRAN_spdf1[["loc"]])
summary(CRAN_spdf1)# 包含 4 slots: bbx, proj4string, coords, data
brazil <- which(CRAN_df$loc == "Brazil")
brazil # index , the cities in Brazil
plot(CRAN_sp[brazil,], axes = TRUE, col = "blue", main = "CRAN Mirrors in Brazil") 
# CRAN_sp[brazil, ] 即为提取CRAN_sp中在Brazil的城市的信息,即4,5,6,7,8行坐标信息,brazil可以看作检索信息
```
##e.g.12:(Spatial Lines)
```{r}
#create the coordinates(创建坐标)
A_coords <- matrix(c(0,4,2,2), nrow = 2, byrow = T) #byrow=T,按行填充
B_coords <- matrix(c(3,2,3,0), nrow = 2, byrow = T)
C_coords <- matrix(c(1,0,1,2), nrow = 2, byrow = T)
D_coords <- matrix(c(0,1,2,1), nrow = 2, byrow = T)
A_coords
#
#Create the Line objects
Line_A <- Line(A_coords)
Line_B <- Line(B_coords)
Line_C <- Line(C_coords)
Line_D <- Line(D_coords)
Line_A
#
#Create the Lines objects
Lines1 <- Lines(list(Line_A, Line_B), "AB")
Lines2 <- Lines(list(Line_C, Line_D), "CD")
Lines1
#
#Create the SpatialLines object
SL <- SpatialLines(list(Lines1, Lines2))
par(mar = c(2,2,2,2))
SL
plot(SL,col="red")
axis(1)#x轴
axis(2)#y轴,单独生成两个坐标轴，无边框
```


###关于plot绘图
```{r}
tempx <- rep(1, times = 5)
#使用rep函数生成由一个数的重复所组成的数列：
tempx
x <- seq(-4, 4, 0.01)
#seq(from,to,length),该函数意思是生成一组数字，从from开始，到to结束，每两个数间的间隔是length
#例如seq(2,10,2)生成的是2 4 6 8 10
tempx <- seq(from=1.0, to=2.0, length.out=5)
#规定输出数列的长度，R软件会自动识别并根据要求生成等增量数列
tempx
y <- x^2
par(mfrow = c(2, 2), mar = c(4, 4, 1, 1))
#使用par() 函数的目的： 
#优化R中默认的图形参数设置，使其能更好地展示自己的数据，避免如坐标轴或者标题出界或者图例说明的大小或者位置遮挡住了图形等情况出现.
#mfrow函数一页多图，par(mfrow = c(2,2))一个图版显示2行2列
#mar函数设置行边距，par(mar = c(4, 4, 1, 1))顺序是下，左，上，右，即下边距和左边距为4行，上边距和右边距为1行
plot(x, y)   # 未作处理
plot(x, y,  xaxs = "i", yaxs ="i")   # 绘图边框未留白
plot(x, y, bty = 'l')   # 只保留左和下两条边框
plot(x, y, ann = F, bty = "n", xaxt = "n", yaxt ="n")   # 边框、坐标轴都去掉
```

---------------------------------------------------------------------------------------------------------------------------
##visual:
###e.g.1:
```{r}
library(sp)
data(meuse)
coordinates(meuse) <- c("x", "y")
plot(meuse,axes = T)#axes = T 生成坐标轴,有四条边框
title("Points")
```

###e.g.2:
```{r}
data(meuse.riv)
meuse.lst <- list(Polygons(list(Polygon(meuse.riv)),"meuse.riv"))
meuse.pol <- SpatialPolygons(meuse.lst)
plot(meuse.pol, col = "grey",axes = T)
title("Polygons")
```

###e.g.3:
```{r}
data(meuse.grid)
coordinates(meuse.grid) <- c("x", "y")
meuse.grid <- as(meuse.grid,"SpatialPixels")
image(meuse.grid, col = "grey", axes = T)
title("Grid")
```

###e.g.4:
```{r}
image(meuse.grid, col = "khaki2")
plot(meuse.pol, col = "lightsteelblue2",add = T)
plot(meuse, add = T,col = "brown", cex = 0.5)
```

###e.g.5:
```{r}
image(meuse.grid, col = "lightgray")
plot(meuse.pol, add = T)
plot(meuse, pch = 1, cex = sqrt(meuse$zinc)/20, add = T)
legVals <- c(100, 200, 500, 1000, 2000)
legend("left", legend = legVals, pch = 1, pt.cex = sqrt(legVals)/20, bty = "n", title = "Measured, ppm", cex = 0.8, y.inter = 0.9)
title("measured and interpolated zinc")
```

###e.g.6:
```{r}
library(RColorBrewer)
grys <- brewer.pal(7, "Reds")
meuse$lead.st = as.vector(scale(meuse$lead))
meuse$zinc.st = as.vector(scale(meuse$zinc))
meuse$copper.st = as.vector(scale(meuse$copper))
meuse$cadmium.st = as.vector(scale(meuse$cadmium))
cuts = c(-1.2, 0, 1, 2, 3, 5)
print(spplot(meuse, c("cadmium.st", "copper.st", "lead.st", "zinc.st"),key.space = "right", main = "standardised",
             layout =c(4,1), cex = 0.5, cuts = cuts, col.regions = grys))
```

###e.g.7:
```{r}
river <- list("sp.polygons", meuse.pol)
bank <- list("sp.polygons", meuse.grid, col="lightgray", alpha=0.2)
print(spplot(meuse, c("cadmium.st", "copper.st", "lead.st", "zinc.st"),
             key.space="right", main = "standardised", layout=c(4,1),
             sp.layout=list(river, bank), cex = .5, cuts = cuts, col.regions=grys))
#
river <- list("sp.polygons", meuse.pol, which = 2)
print(spplot(meuse, 
             c("cadmium.st", "copper.st", "lead.st", "zinc.st"),
             key.space="right", main = "standardised", 
             layout=c(4,1), sp.layout=list(river, bank), 
             cex = .5, cuts = cuts, col.regions=grys))
```

###e.g.8:
```{r}
rainbow(n = 3)
col.out <- cm.colors(n = 7)
print(spplot(meuse, "cadmium.st", key.space = "right",
             main = "standardised", 
             sp.layout = river, cuts = cuts, 
             col.regions = col.out))

#
rw.colors <- colorRampPalette(c("red","blue"))
print(spplot(meuse, "cadmium.st", key.space = "right",
             main = "standardised", 
             sp.layout = river, cuts = cuts, 
             col.regions = rw.colors(7)))
```

###e.g.9:
```{r}
library(classInt)
q5 <- classIntervals(meuse$zinc, n=5, style = "quantile")
q5
fj5 <- classIntervals(meuse$zinc, n=5, style = "fisher")
fj5
```

###e.g.10:
```{r}
pal <- brewer.pal(n=5, "Reds")
spplot(meuse, "zinc", cuts = q5$brks, col.regions = pal,
       key.space = "left", main = "Quantiles")
```

###tut
```{r}

```
